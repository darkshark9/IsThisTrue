name: Build/Release

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    
    strategy:
      matrix:
        os: [windows-latest, macos-latest]

    steps:
    - name: Check out Git repository
      uses: actions/checkout@v4

    - name: Install Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'npm'
        cache-dependency-path: electron-app/package-lock.json

    - name: Install Dependencies
      run: npm ci
      working-directory: electron-app

    - name: Build Electron App
      run: |
        if [ "$RUNNER_OS" == "Windows" ]; then
          npm run build:win
        elif [ "$RUNNER_OS" == "macOS" ]; then
          npm run build:mac
        fi
      shell: bash
      working-directory: electron-app
      env:
        CSC_IDENTITY_AUTO_DISCOVERY: "false"

    - name: Sign macOS app and create DMG
      if: runner.os == 'macOS'
      run: |
        set -e

        # Find the .app that electron-builder produced (BSD/macOS find-compatible)
        APP_PATH=$(find dist -type d -name "*.app" -prune -print | head -n 1)
        if [ -z "$APP_PATH" ]; then
          echo "ERROR: No .app found in dist/"
          ls -laR dist/
          exit 1
        fi
        echo "Found app: $APP_PATH"

        # Use the entitlements file we created
        ENTITLEMENTS="entitlements.mac.plist"
        if [ ! -f "$ENTITLEMENTS" ]; then
          echo "ERROR: Entitlements file not found at $ENTITLEMENTS"
          exit 1
        fi

        echo "=== Ad-hoc signing (inside-out) ==="

        # 1. Sign all native modules, dylibs, and shared objects
        echo "Signing native modules and libs..."
        find "$APP_PATH" -type f \( -name "*.node" -o -name "*.dylib" -o -name "*.so" \) -print -exec codesign --force --options runtime --sign - {} \;

        # 2. Sign all frameworks
        echo "Signing frameworks..."
        find "$APP_PATH/Contents/Frameworks" -name "*.framework" -print -exec codesign --force --options runtime --sign - {} \;

        # 3. Sign all nested helper apps
        echo "Signing helper apps..."
        find "$APP_PATH/Contents/Frameworks" -name "*.app" -print -exec codesign --force --options runtime --entitlements "$ENTITLEMENTS" --sign - {} \;

        # 4. Sign the main app last
        echo "Signing main app..."
        codesign --force --options runtime --entitlements "$ENTITLEMENTS" --sign - "$APP_PATH"

        # Verify signature
        echo "=== Verifying signature ==="
        codesign -dvv "$APP_PATH" 2>&1 || true
        codesign --verify --verbose "$APP_PATH" 2>&1 || true
        echo "Signing complete."

        # Create DMG from the signed .app
        echo "=== Creating DMG ==="
        APP_VERSION=$(node -p "require('./package.json').version")
        DMG_NAME="Is-This-True-${APP_VERSION}-arm64.dmg"

        # Create a temporary folder with the app and an Applications symlink
        STAGE_DIR=$(mktemp -d)
        cp -R "$APP_PATH" "$STAGE_DIR/"
        ln -s /Applications "$STAGE_DIR/Applications"

        hdiutil create \
          -volname "Is This True?" \
          -srcfolder "$STAGE_DIR" \
          -ov \
          -format UDZO \
          "dist/$DMG_NAME"

        rm -rf "$STAGE_DIR"
        echo "DMG created: dist/$DMG_NAME"
        ls -lh "dist/$DMG_NAME"
      working-directory: electron-app

    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.os }}-installer
        path: |
          electron-app/dist/*.exe
          electron-app/dist/*.dmg
          electron-app/dist/*.zip

  release:
    needs: build
    if: github.ref_type == 'tag' && startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
    - name: Download all installers
      uses: actions/download-artifact@v4
      with:
        pattern: '*-installer'
        path: release
        merge-multiple: true

    - name: Create GitHub Release and upload installers
      uses: softprops/action-gh-release@v2
      with:
        files: release/*
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
